<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>SmartSnippets DA1468x SDK: UART_ADAPTER</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SmartSnippets DA1468x SDK
   &#160;<span id="projectnumber">Version 1.0.6.968</span>
   </div>
   <div id="projectbrief">Bluetooth Smart</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART_ADAPTER<div class="ingroups"><a class="el" href="group___b_s_p.html">BSP</a> &raquo; <a class="el" href="group___a_d_a_p_t_e_r_s.html">ADAPTERS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>UART adapter.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:ad__uart_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ad__uart_8h.html">ad_uart.h</a></td></tr>
<tr class="memdesc:ad__uart_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART adapter API. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__bus__dynamic__data.html">uart_bus_dynamic_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART device data run time data.  <a href="structuart__bus__dynamic__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structuart__device__config.html">uart_device_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART bus constant data.  <a href="structuart__device__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga60e617d96d1ccd9d442b62be87ca345c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga60e617d96d1ccd9d442b62be87ca345c">UART_BUS</a>(bus_id, name, _baud_rate, data_bits, _parity, _stop, _auto_flow_control, _use_fifo, dma_channel_tx, dma_channel_rx, tx_fifo_tr_lvl, rx_fifo_tr_lvl)&#160;&#160;&#160;extern const void *const name;</td></tr>
<tr class="memdesc:ga60e617d96d1ccd9d442b62be87ca345c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry for slave device.  <a href="#ga60e617d96d1ccd9d442b62be87ca345c">More...</a><br /></td></tr>
<tr class="separator:ga60e617d96d1ccd9d442b62be87ca345c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga59d3ae66a401dd3921cf2775ffa78439"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59d3ae66a401dd3921cf2775ffa78439"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a></td></tr>
<tr class="memdesc:ga59d3ae66a401dd3921cf2775ffa78439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device pointer, handle to use with <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga2035b1344458d57da35b1a459b83ff7f" title="Read from UART. ">ad_uart_read()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad3161397e053e5230fca67febc9e2147" title="Write to UART. ">ad_uart_write()</a> etc. <br /></td></tr>
<tr class="separator:ga59d3ae66a401dd3921cf2775ffa78439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9957354b1c342143b9b03457533fef3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9957354b1c342143b9b03457533fef3"></a>
typedef const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad9957354b1c342143b9b03457533fef3">uart_device_id</a></td></tr>
<tr class="memdesc:gad9957354b1c342143b9b03457533fef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device id, those are created by UART_BUS macro in <a class="el" href="platform__devices_8h.html" title="Configuration of devices connected to board. ">platform_devices.h</a>. <br /></td></tr>
<tr class="separator:gad9957354b1c342143b9b03457533fef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6fe9f3dc57545cea2a2183adae7c11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gada6fe9f3dc57545cea2a2183adae7c11"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gada6fe9f3dc57545cea2a2183adae7c11">ad_uart_user_cb</a> )(void *user_data, uint16_t transferred)</td></tr>
<tr class="memdesc:gada6fe9f3dc57545cea2a2183adae7c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous callback function. <br /></td></tr>
<tr class="separator:gada6fe9f3dc57545cea2a2183adae7c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c5ede3587564c6c07b2726c3a03b738"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structuart__device__config.html">uart_device_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga4c5ede3587564c6c07b2726c3a03b738">uart_device_config</a></td></tr>
<tr class="memdesc:ga4c5ede3587564c6c07b2726c3a03b738"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART bus constant data.  <a href="#ga4c5ede3587564c6c07b2726c3a03b738">More...</a><br /></td></tr>
<tr class="separator:ga4c5ede3587564c6c07b2726c3a03b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3d668bfee8a2e988061209ade5a3018c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3d668bfee8a2e988061209ade5a3018c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga3d668bfee8a2e988061209ade5a3018c">ad_uart_init</a> (void)</td></tr>
<tr class="memdesc:ga3d668bfee8a2e988061209ade5a3018c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize adapter. <br /></td></tr>
<tr class="separator:ga3d668bfee8a2e988061209ade5a3018c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cb703a8b6387af205368cbd3de0fe8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8">ad_uart_open</a> (const <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad9957354b1c342143b9b03457533fef3">uart_device_id</a> dev_id)</td></tr>
<tr class="memdesc:ga07cb703a8b6387af205368cbd3de0fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open UART device.  <a href="#ga07cb703a8b6387af205368cbd3de0fe8">More...</a><br /></td></tr>
<tr class="separator:ga07cb703a8b6387af205368cbd3de0fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3161397e053e5230fca67febc9e2147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad3161397e053e5230fca67febc9e2147">ad_uart_write</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, const char *wbuf, size_t wlen)</td></tr>
<tr class="memdesc:gad3161397e053e5230fca67febc9e2147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write to UART.  <a href="#gad3161397e053e5230fca67febc9e2147">More...</a><br /></td></tr>
<tr class="separator:gad3161397e053e5230fca67febc9e2147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae193afb0033c24fbcdd28fb75a2d6683"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gae193afb0033c24fbcdd28fb75a2d6683">ad_uart_write_async</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, const char *wbuf, size_t wlen, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gada6fe9f3dc57545cea2a2183adae7c11">ad_uart_user_cb</a> cb, void *user_data)</td></tr>
<tr class="memdesc:gae193afb0033c24fbcdd28fb75a2d6683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous write to UART.  <a href="#gae193afb0033c24fbcdd28fb75a2d6683">More...</a><br /></td></tr>
<tr class="separator:gae193afb0033c24fbcdd28fb75a2d6683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2035b1344458d57da35b1a459b83ff7f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga2035b1344458d57da35b1a459b83ff7f">ad_uart_read</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, char *rbuf, size_t rlen, OS_TICK_TIME timeout)</td></tr>
<tr class="memdesc:ga2035b1344458d57da35b1a459b83ff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from UART.  <a href="#ga2035b1344458d57da35b1a459b83ff7f">More...</a><br /></td></tr>
<tr class="separator:ga2035b1344458d57da35b1a459b83ff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc22af2273d137b69f7afaf775fd3f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9">ad_uart_read_async</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev, char *rbuf, size_t rlen, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gada6fe9f3dc57545cea2a2183adae7c11">ad_uart_user_cb</a> cb, void *user_data)</td></tr>
<tr class="memdesc:gaacc22af2273d137b69f7afaf775fd3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start asynchronous read from UART.  <a href="#gaacc22af2273d137b69f7afaf775fd3f9">More...</a><br /></td></tr>
<tr class="separator:gaacc22af2273d137b69f7afaf775fd3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00ea78f7363e4cc20f6694112a2d4c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga00ea78f7363e4cc20f6694112a2d4c76">ad_uart_abort_read_async</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga00ea78f7363e4cc20f6694112a2d4c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abort previously started asynchronous read.  <a href="#ga00ea78f7363e4cc20f6694112a2d4c76">More...</a><br /></td></tr>
<tr class="separator:ga00ea78f7363e4cc20f6694112a2d4c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c84afdc598a9ea42cdc3452f30395a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a">ad_uart_bus_acquire</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga43c84afdc598a9ea42cdc3452f30395a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire access to UART bus.  <a href="#ga43c84afdc598a9ea42cdc3452f30395a">More...</a><br /></td></tr>
<tr class="separator:ga43c84afdc598a9ea42cdc3452f30395a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06924897ddd0c212a1eecdc37a7c1ff4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4">ad_uart_bus_release</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga06924897ddd0c212a1eecdc37a7c1ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release access to UART bus.  <a href="#ga06924897ddd0c212a1eecdc37a7c1ff4">More...</a><br /></td></tr>
<tr class="separator:ga06924897ddd0c212a1eecdc37a7c1ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8ee4d7d02f58dbdca2609808d264cd"><td class="memItemLeft" align="right" valign="top">HW_UART_ID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga6f8ee4d7d02f58dbdca2609808d264cd">ad_uart_get_hw_uart_id</a> (<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> dev)</td></tr>
<tr class="memdesc:ga6f8ee4d7d02f58dbdca2609808d264cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get UART controller id.  <a href="#ga6f8ee4d7d02f58dbdca2609808d264cd">More...</a><br /></td></tr>
<tr class="separator:ga6f8ee4d7d02f58dbdca2609808d264cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>UART adapter. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga60e617d96d1ccd9d442b62be87ca345c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UART_BUS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bus_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_baud_rate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data_bits, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_parity, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_stop, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_auto_flow_control, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_use_fifo, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel_tx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dma_channel_rx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_fifo_tr_lvl, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_fifo_tr_lvl&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;extern const void *const name;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Entry for slave device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bus_id</td><td>valid values: UART1, UART2 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>of uart may be COM1, or something like this </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_baud_rate</td><td>required uart baud rate from enum HW_UART_BAUDRATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_bits</td><td>value from enum HW_UART_DATABITS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_parity</td><td>value from enum HW_UART_PARITY </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_stop</td><td>value from enum HW_UART_STOPBITS </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_auto_flow_control</td><td>if 1 auto flow control should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_use_fifo</td><td>if 1 fifo should be used </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_tx</td><td>DMA number for tx channel, rx msut have the previous number, pass HW_DMA_CHANNEL_INVALID for no DMA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dma_channel_rx</td><td>DMA number for rx channel, tx must have the next number, pass HW_DMA_CHANNEL_INVALID for no DMA </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_fifo_tr_lvl</td><td>the tx fifo trigger level, valid numbers 0..3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rx_fifo_tr_lvl</td><td>the rx fifo trigger level, valid numbers 0..3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga4c5ede3587564c6c07b2726c3a03b738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structuart__device__config.html">uart_device_config</a>  <a class="el" href="structuart__device__config.html">uart_device_config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART bus constant data. </p>
<p>Variable of this type keeps static configuration needed to configure UART bus. Those variables are generated by <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga60e617d96d1ccd9d442b62be87ca345c" title="Entry for slave device. ">UART_BUS()</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga00ea78f7363e4cc20f6694112a2d4c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_abort_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Abort previously started asynchronous read. </p>
<p>This function aborts asynchronous read started with </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a>. To avoid unpredictable results <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a> must be called before <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a>, because <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> can be called from interrupt fired after user code decided to abort read operation. In that case <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> could already release uart for other tasks and calling abort would interfere with next read. If resource is blocked there is no risk of calling abort when read is finishing. User callback will be called only once.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gaacc22af2273d137b69f7afaf775fd3f9" title="Start asynchronous read from UART. ">ad_uart_read_async()</a> </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga43c84afdc598a9ea42cdc3452f30395a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_bus_acquire </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquire access to UART bus. </p>
<p>This function waits for UART bus to be available, and locks it for current task's use only. This function can be called several times, but number of <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> calls must match number of calls to this function.</p>
<p>This function should be used if normal <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga2035b1344458d57da35b1a459b83ff7f" title="Read from UART. ">ad_uart_read()</a>, <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad3161397e053e5230fca67febc9e2147" title="Write to UART. ">ad_uart_write()</a> are not enough and some other UART controller calls are required. In this case typical usage for this function would look like this:</p>
<p>ad_uart_bus_acquire(dev); id = ad_uart_get_hw_uart_id(dev); ... hw_uart_set...(id, ...); hw_uart_write_buffer(id, ...) ... ad_uart_bus_release(dev);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga06924897ddd0c212a1eecdc37a7c1ff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_bus_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release access to UART bus. </p>
<p>This function decrements acquire counter for this device and when it reaches 0 UART bus is released and can be used by other tasks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6f8ee4d7d02f58dbdca2609808d264cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HW_UART_ID ad_uart_get_hw_uart_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get UART controller id. </p>
<p>This function returns id that can be used to get UART controller id. This id is argument for lower level functions starting with hw_uart_ prefix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>id that can be used with hw_uart_... functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga07cb703a8b6387af205368cbd3de0fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a> ad_uart_open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gad9957354b1c342143b9b03457533fef3">uart_device_id</a>&#160;</td>
          <td class="paramname"><em>dev_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open UART device. </p>
<p>First call to this function will configure UART block. Later calls from other tasks will just return handle to already initialized UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev_id</td><td>identifier as passed to to <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga60e617d96d1ccd9d442b62be87ca345c" title="Entry for slave device. ">UART_BUS()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device handle that can be used with other functions </dd></dl>

</div>
</div>
<a class="anchor" id="ga2035b1344458d57da35b1a459b83ff7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ad_uart_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OS_TICK_TIME&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read from UART. </p>
<p>This function reads rlen bytes from UART. This function is blocking. It can wait first for bus access, then it waits till transaction is completed. If timeout is OS_EVENT_FOREVER, exactly <code>rlen</code> bytes must be received. If timeout is specified, function can exit after timeout with less bytes than requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>pointer to data to be read from UART </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>time in ticks to wait for data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, 0 if no data arrived in specified time</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
ad_uart_close() </dd></dl>

</div>
</div>
<a class="anchor" id="gaacc22af2273d137b69f7afaf775fd3f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_read_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gada6fe9f3dc57545cea2a2183adae7c11">ad_uart_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous read from UART. </p>
<p>This function sets up read of <code>rlen</code> bytes from UART. While this function does not wait for read operation to finish it will start from gaining access to UART resource by calling </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a>. If function should not block at all user should call </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga43c84afdc598a9ea42cdc3452f30395a" title="Acquire access to UART bus. ">ad_uart_bus_acquire()</a> before.</dd></dl>
<p>When read operation is started, user must not release memory pointer <code>rbuf</code>. After data is received <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> will be called just before user callback is executed.</p>
<p>To abort started read operation <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga00ea78f7363e4cc20f6694112a2d4c76" title="Abort previously started asynchronous read. ">ad_uart_abort_read_async()</a> should be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rbuf</td><td>pointer to data to be read from UART </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rlen</td><td>size of buffer pointed by rbuf </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>function to call after write is finished or aborted </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>pointer to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
ad_uart_close() </dd>
<dd>
<a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga00ea78f7363e4cc20f6694112a2d4c76" title="Abort previously started asynchronous read. ">ad_uart_abort_read_async()</a></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The callback is called from within UART ISR and at that time resources are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
<a class="anchor" id="gad3161397e053e5230fca67febc9e2147"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write to UART. </p>
<p>This function performs write to UART. This function is blocking. It can wait first for bus access, then it waits till transaction is completed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>pointer to data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
ad_uart_close() </dd></dl>

</div>
</div>
<a class="anchor" id="gae193afb0033c24fbcdd28fb75a2d6683"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ad_uart_write_async </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga59d3ae66a401dd3921cf2775ffa78439">uart_device</a>&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>wbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>wlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#gada6fe9f3dc57545cea2a2183adae7c11">ad_uart_user_cb</a>&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start asynchronous write to UART. </p>
<p>This function sets up write of <code>wlen</code> bytes to UART. When write is done user callback <code>cb</code> will be called just after <a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga06924897ddd0c212a1eecdc37a7c1ff4" title="Release access to UART bus. ">ad_uart_bus_release()</a> is called. When write operation is started, user must not release memory pointer <code>wbuf</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dev</td><td>handle to UART device </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wbuf</td><td>pointer to data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wlen</td><td>size of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>function to call after write finishes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>pointer to pass to <code>cb</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___u_a_r_t___a_d_a_p_t_e_r.html#ga07cb703a8b6387af205368cbd3de0fe8" title="Open UART device. ">ad_uart_open()</a> </dd>
<dd>
ad_uart_close()</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The callback is called from within UART ISR and at that time resources are released</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not call this function consecutively without guaranteeing that the previous async transaction has completed.</dd>
<dd>
After the callback is called, it is not guaranteed that the scheduler will give control to the task waiting for this transaction to complete. This is important to consider if more than one tasks are using this API. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 22 2016 19:41:08 for SmartSnippets DA1468x SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
